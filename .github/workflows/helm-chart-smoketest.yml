name: Helm Chart Smoketest

on:
  workflow_call:

permissions:
  contents: read

env:
  K8S_VERSION: v1.32.3
  MICROK8S_CHANNEL: 1.32/stable
  SHIM_SPIN_VERSION: v0.22.0
  DOCKER_BUILD_SUMMARY: false

jobs:
  build-images:
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        config:
          - {
              name: "runtime-class-manager",
              context: ".",
              file: "./Dockerfile"
            }
          - {
              name: "shim-downloader",
              context: "./images/downloader",
              file: "./images/downloader/Dockerfile"
            }
          - {
              name: "node-installer",
              context: ".",
              file: "./images/installer/Dockerfile"
            }
    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Set up QEMU
        uses: docker/setup-qemu-action@c7c53464625b32c7a7e944ae62b3e17d2b600130 # v3.7.0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0

      - name: Build ${{ matrix.config.name }}
        uses: docker/build-push-action@10e90e3645eae34f1e60eeb005ba3a3d33f178e8 # v6.19.2
        with:
          context: ${{ matrix.config.context }}
          file: ${{ matrix.config.file }}
          platforms: linux/amd64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker,dest=/tmp/${{ matrix.config.name }}.tar
          tags: ${{ matrix.config.name }}:chart-test

      - name: Upload artifact
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: image-${{ matrix.config.name }}
          path: /tmp/${{ matrix.config.name }}.tar

  helm-install-smoke-test:
    runs-on: ubuntu-22.04
    needs: build-images
    strategy:
      matrix:
        config:
          - {
              type: "kind",
              import_cmd: "kind load image-archive"
            }
          - {
              type: "minikube",
              import_cmd: "minikube image load"
            }
          - {
              type: "microk8s",
              import_cmd: "sudo microk8s ctr images import"
            }
          - {
              type: "k3d",
              import_cmd: "k3d image import"
            }

    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Install helm
        uses: Azure/setup-helm@1a275c3b69536ee54be43f2070a358922e12c8d4 # v4.3.1
        with:
          version: v3.17.2

      - name: Download artifact
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        with:
          pattern: image-*
          merge-multiple: true
          path: /tmp

      # Note: 'uses' doesn't support variable interpolation, hence the
      # k8s-specific steps below.
      # Ref: https://github.com/orgs/community/discussions/25824
      - name: Create kind cluster
        if: matrix.config.type == 'kind'
        uses: helm/kind-action@92086f6be054225fa813e0a4b13787fc9088faab # v1.13.0
        with:
          cluster_name: kind
          # Versions lower than v0.27.0 encounter https://github.com/kubernetes-sigs/kind/issues/3795
          version: v0.27.0
          node_image: kindest/node:${{ env.K8S_VERSION }}

      - name: Create minikube cluster
        if: matrix.config.type == 'minikube'
        run: |
          curl -LO https://github.com/kubernetes/minikube/releases/latest/download/minikube-linux-amd64
          install minikube-linux-amd64 /usr/local/bin/minikube && rm minikube-linux-amd64
          docker build -t minikube-custom:v0.0.46-fixed -f ./images/test/Dockerfile.minikube-custom . --load
          minikube start -p minikube --driver=docker --container-runtime=containerd --base-image="minikube-custom:v0.0.46-fixed" --kubernetes-version=${{ env.K8S_VERSION }}
          kubectl wait pod --all --for=condition=Ready --namespace=kube-system --timeout=180s

      - name: Create microk8s cluster
        if: matrix.config.type == 'microk8s'
        uses: balchua/microk8s-actions@13f73436011eb4925c22526f64fb3ecdd81289a9 # v0.4.3
        with:
          channel: ${{ env.MICROK8S_CHANNEL }}

      - name: Create k3d cluster
        if: matrix.config.type == 'k3d'
        uses: AbsaOSS/k3d-action@4e8b3239042be1dc0aed6c5eb80c13b18200fc79 # v2.4.0
        with:
          cluster-name: k3s-default
          k3d-version: v5.8.3
          args: |
            --image docker.io/rancher/k3s:${{ env.K8S_VERSION }}-k3s1

      - name: Import images
        run: |
          for image in $(ls /tmp/*.tar); do
            ${{ matrix.config.import_cmd }} $image
          done

      - name: helm install runtime-class-manager
        run: |
          helm install rcm \
            --namespace rcm \
            --create-namespace \
            --debug \
            --set image.repository=runtime-class-manager \
            --set image.tag=chart-test \
            --set rcm.nodeInstallerImage.repository=node-installer \
            --set rcm.nodeInstallerImage.tag=chart-test \
            --set rcm.shimDownloaderImage.repository=shim-downloader \
            --set rcm.shimDownloaderImage.tag=chart-test \
            deploy/helm

      - name: apply shims
        run: |
          for shim_file in $(ls config/samples/sample_shim*); do
            if [[ "${{ matrix.config.type }}" == "microk8s" ]]; then
              cp $shim_file $shim_file.microk8s
              shim_file=$shim_file.microk8s
              # update file to remove the 'containerdRuntimeOptions' field
              # as there is a known bug that MicroK8s containerd does not pass the options
              yq -i 'del(.spec.containerdRuntimeOptions)' $shim_file
            fi
            kubectl apply -f $shim_file
          done

      - name: label nodes and wait for shim to be ready
        run: |
          for shim_file in $(ls config/samples/sample_shim*); do
            label="$(cat $shim_file | yq '.spec.nodeSelector' | tr -d '"' | tr -d '[:space:]' | sed s/:/=/g)"
            kubectl label node --all $label

            shim_name="$(cat $shim_file | yq '.metadata.name')"
            # TODO: k3d can take a long round of failed install pods (exit code 6 when curling the artifact?)
            # Once this behavior is diagnosed and resolved, we should be able to shorten this timeout substantially
            timeout=600
            SECONDS=0 # Reset the internal bash timer to 0
            success=false

            echo "Waiting for the $shim_name shim to be ready/installed..."

            while [[ $SECONDS -lt $timeout ]]; do
              # Fetch both nodes and nodesReady
              read -r nodes nodesReady <<< $(kubectl get shim "$shim_name" \
                -o jsonpath='{.status.nodes} {.status.nodesReady}' 2>/dev/null)

              # Check to see if all nodes are ready
              if [[ -n "$nodes" ]] && [[ -n "$nodesReady" ]] && [[ "$nodes" -eq "$nodesReady" ]]; then
                echo "Success: all nodes have the $shim_name shim installed."
                success=true
                break
              fi

              sleep 2
            done

            if [[ "${success}" != "true" ]]; then
              echo "Error: Timed out after ${timeout}s waiting for the $shim_name shim to be ready."
              exit 1
            fi
          done

      # TODO: unify testdata/apps to all model the same behavor, eg simple web server, etc
      - name: run and verify spin app
        run: |
          kubectl apply -f testdata/apps/spin-v2-app.yaml
          kubectl rollout status deployment spin-v2-app --timeout 180s
          kubectl port-forward svc/spin-v2-app 8083:80 &
          timeout 60s bash -c 'until curl -f -vvv http://localhost:8083/hello; do sleep 2; done'

      - name: run and verify wasmtime app
        run: |
          kubectl apply -f testdata/apps/wasmtime-v1-app.yaml
          kubectl rollout status deployment wasmtime-v1-app --timeout 180s
          pod=$(kubectl get pod -l app=wasmtime-v1-app -o name)
          timeout 60s bash -c 'until kubectl logs $1 | grep -q "This is a song that never ends."; do sleep 2; done' -- $pod

      - name: debug
        if: failure()
        run: |
          kubectl get pods -A
          kubectl describe shims
          kubectl describe runtimeclasses

          # Get install pod logs
          # Note: there may be multiple pods pending k3d fix for issue https://github.com/spinframework/runtime-class-manager/issues/393
          for shim_file in $(ls config/samples/sample_shim*); do
            shim_name="$(cat $shim_file | yq '.metadata.name')"
            install_pods="$(kubectl get pods -n rcm --no-headers -o name | grep $shim_name-install)"
            for pod in $install_pods; do
              kubectl describe -n rcm $pod || true
              kubectl logs -n rcm -c downloader $pod || true
              kubectl logs -n rcm -c provisioner $pod || true
            done
          done

          # RCM pod logs
          kubectl logs -n rcm -l app.kubernetes.io/name=runtime-class-manager || true
          kubectl describe -n rcm pod -l app.kubernetes.io/name=runtime-class-manager || true

          # App logs
          for app_file in $(ls testdata/apps/*); do
            app=$(cat $app_file | yq 'select(.kind == "Deployment") | .metadata.name')
            kubectl logs -l app=$app || true
            kubectl describe pod -l app=$app || true
          done
