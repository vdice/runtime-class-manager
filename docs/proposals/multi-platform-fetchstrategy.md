# Multi-Platform `fetchStrategy` for the Shim CRD

**Status:** Implemented  
**Date:** 2026-02-18  
**Authors:** Runtime Class Manager contributors

---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Inspiration](#inspiration)
3. [CRD Schema](#crd-schema)
4. [Example Custom Resource Manifests](#example-custom-resource-manifests)
5. [Controller Logic for Artifact Resolution](#controller-logic-for-artifact-resolution)
6. [Backward Compatibility](#backward-compatibility)
7. [Trade-offs and Edge Cases](#trade-offs-and-edge-cases)

---

## Problem Statement

Previously the `Shim` CRD's `fetchStrategy` supported only a single `anonHttp.location` URL:

```yaml
fetchStrategy:
  anonHttp:
    location: "https://github.com/.../containerd-shim-spin-v2-linux-aarch64.tar.gz"
```

This had two main limitations:

1. **Single-architecture only** — the URL is hard-coded to one OS/arch pair (e.g., `linux-aarch64`). Mixed clusters with both `amd64` and `arm64` nodes cannot be served by a single Shim resource.
2. **No artifact verification** — there is no checksum or digest field to verify the downloaded binary.

---

## Inspiration

The design is inspired by [Krew](https://krew.sigs.k8s.io/) (the kubectl plugin manager), which defines per-platform artifacts in its plugin index manifests:

```yaml
platforms:
  - selector:
      matchLabels:
        os: linux
        arch: amd64
    uri: https://github.com/.../v0.5.0/krew-linux_amd64.tar.gz
    sha256: abc123...
  - selector:
      matchLabels:
        os: linux
        arch: arm64
    uri: https://github.com/.../v0.5.0/krew-linux_arm64.tar.gz
    sha256: def456...
```

The key pattern is an explicit `platforms` list where each entry maps an OS/architecture pair to an artifact URI and optional checksum. This approach is clear, requires no magic, and is the natural fit for operators that download standalone binaries.

**Our simplification over Krew**: Instead of using Kubernetes-style `selector.matchLabels`, we use flat `os` and `arch` fields directly on each platform entry. This is simpler for our use case (artifacts are keyed exclusively by OS + architecture) and allows the controller to transparently normalize architecture names — users can write either Go-style (`amd64`, `arm64`) or uname-style (`x86_64`, `aarch64`) and both work. With label selectors, users would be forced to use the exact values from `kubernetes.io/arch` labels.

---

## CRD Schema

### Design Principles

1. **Backward compatible** — existing `anonHttp.location` continues to work unchanged.
2. **Platform-aware** — a single Shim resource can target multiple OS/arch combinations.
3. **Verifiable** — optional `sha256` digest per platform artifact.
4. **Simple** — flat `os`/`arch` fields, no nested selectors.

### Go Types (`api/v1alpha1/shim_types.go`)

```go
type FetchStrategy struct {
	AnonHTTP *AnonHTTPSpec `json:"anonHttp,omitempty"`
	Platforms []PlatformArtifact `json:"platforms,omitempty"`
}

// AnonHTTPSpec defines a simple anonymous HTTP fetch (single URL, single architecture).
type AnonHTTPSpec struct {
	Location string `json:"location"`
}

// PlatformArtifact maps a specific OS/Arch pair to an artifact URL.
type PlatformArtifact struct {
	OS string `json:"os"`
	Arch string `json:"arch"`
	Location string `json:"location"`
	SHA256 string `json:"sha256,omitempty"`
}
```

### CRD YAML (generated by controller-gen)

```yaml
fetchStrategy:
  properties:
    anonHttp:
      properties:
        location:
          type: string
      required: [location]
      type: object
    platforms:
      type: array
      items:
        properties:
          os:
            type: string
            enum:
            - linux
          arch:
            type: string
            enum:
            - amd64
            - arm64
            - x86_64
            - aarch64
          location:
            type: string
          sha256:
            type: string
        required: [os, arch, location]
        type: object
  type: object
```

---

## Example Custom Resource Manifests

### Example 1: Legacy Single-URL (Backward Compatible)

Existing CRs continue to work without any changes:

```yaml
apiVersion: runtime.spinkube.dev/v1alpha1
kind: Shim
metadata:
  name: spin-v2
spec:
  nodeSelector:
    spin: "true"
  fetchStrategy:
    anonHttp:
      location: "https://github.com/spinframework/containerd-shim-spin/releases/download/v0.22.0/containerd-shim-spin-v2-linux-aarch64.tar.gz"
  runtimeClass:
    name: wasmtime-spin-v2
    handler: spin-v2
  rolloutStrategy:
    type: recreate
```

### Example 2: Multi-Platform

For mixed amd64/arm64 clusters, the controller picks the right artifact per node:

```yaml
apiVersion: runtime.spinkube.dev/v1alpha1
kind: Shim
metadata:
  name: spin-v2
spec:
  nodeSelector:
    spin: "true"
  fetchStrategy:
    platforms:
      - os: linux
        arch: aarch64
        location: "https://github.com/spinframework/containerd-shim-spin/releases/download/v0.22.0/containerd-shim-spin-v2-linux-aarch64.tar.gz"
      - os: linux
        arch: x86_64
        location: "https://github.com/spinframework/containerd-shim-spin/releases/download/v0.22.0/containerd-shim-spin-v2-linux-x86_64.tar.gz"
  runtimeClass:
    name: wasmtime-spin-v2
    handler: spin-v2
  rolloutStrategy:
    type: recreate
```

### Example 3: Multi-Platform with SHA-256 Verification

Each platform entry can include a SHA-256 digest. The downloader verifies the checksum after downloading:

```yaml
apiVersion: runtime.spinkube.dev/v1alpha1
kind: Shim
metadata:
  name: spin-v2
spec:
  nodeSelector:
    spin: "true"
  fetchStrategy:
    platforms:
      - os: linux
        arch: aarch64
        location: "https://github.com/spinframework/containerd-shim-spin/releases/download/v0.22.0/containerd-shim-spin-v2-linux-aarch64.tar.gz"
        sha256: "a1b2c3d4e5f6..."
      - os: linux
        arch: x86_64
        location: "https://github.com/spinframework/containerd-shim-spin/releases/download/v0.22.0/containerd-shim-spin-v2-linux-x86_64.tar.gz"
        sha256: "f6e5d4c3b2a1..."
  runtimeClass:
    name: wasmtime-spin-v2
    handler: spin-v2
  rolloutStrategy:
    type: recreate
```

---

## Controller Logic for Artifact Resolution

### Overview

Artifact URL resolution now happens **per node** instead of per Shim. Previously, `shim.Spec.FetchStrategy.AnonHTTP.Location` was a single URL passed to every node's downloader init container. Now, `resolveArtifactForNode()` selects the correct artifact for each node based on `node.Status.NodeInfo`.

### Resolution Algorithm

The controller uses the following precedence:

1. **Platforms** — if `fetchStrategy.platforms` is non-empty, find the entry matching the node's OS and architecture. Error if no match is found.
2. **AnonHTTP fallback** — if no platforms are specified, use `fetchStrategy.anonHttp.location` directly (backward compatible path).
3. **Error** — if neither is configured, fail with a descriptive error.

### Implementation (`shim_controller.go`)

When deploying a shim install Job for a node, the controller calls `resolveArtifactForNode()` to determine the download URL and optional SHA-256 digest. This function reads the node's OS and architecture from `node.Status.NodeInfo` and returns a `resolvedArtifact` (an internal struct with `location` and `sha256` fields), abstracting over whether the source was `platforms` or `anonHttp`.

### Architecture Matching

Platform matching is case-insensitive and normalizes between Go-style and uname-style architecture names. For example, a platform entry with `arch: x86_64` matches a node reporting `Architecture: amd64`, and vice versa. The supported mappings are `amd64` ↔ `x86_64`, `arm64` ↔ `aarch64`, and `arm` ↔ `armv7l`.

### Mixed-Architecture Cluster Behavior

Artifact resolution happens independently per node. In a cluster with both supported and unsupported architectures, the controller deploys Jobs to supported nodes and surfaces errors for unsupported ones — it does not fail the entire operation.

### Downloader Changes

The `download_shim.sh` script now supports optional SHA-256 verification via the `SHIM_SHA256` environment variable. When set, the script verifies the digest after download and exits with a logged error if verification fails. The env var is only set on the init container when the resolved artifact has a non-empty `sha256` field.

---

## Backward Compatibility

This change is **fully backward compatible**. Both `anonHttp` and `platforms` are optional fields.

| Existing CR Field | Behavior After This Change | Notes |
|---|---|---|
| `fetchStrategy.anonHttp.location` | Works as-is | Falls through to AnonHTTP path |
| No `platforms` field | No change | Controller uses AnonHTTP |
| `fetchStrategy.type` | Deprecated | Field was unused by controller |

Existing Shim CRs that use `anonHttp.location` require **zero changes** and continue to work exactly as before. The `type` field was deprecated since the controller now determines the strategy by checking which fields are populated (platforms first, then anonHttp).

---

## Trade-offs and Edge Cases

### Design Decisions

| Decision | Rationale | Alternative Considered |
|---|---|---|
| Flat `os`/`arch` fields vs label selectors | Simpler YAML; allows transparent arch normalization (`arm64` ↔ `aarch64`) | Krew-style `selector.matchLabels` — forces exact K8s label values |
| Architecture normalization in controller | Different projects use different conventions; users shouldn't need to know K8s uses Go-style names | Require Go-style arch names only — limits usability |
| `platforms` takes precedence over `anonHttp` | Clear, predictable behavior; avoids accidentally using wrong-arch fallback | Use `anonHttp` as fallback when no platform matches — risky |
| `sha256` per platform entry | Natural placement; each platform has its own binary with its own digest | Global verification field — doesn't work for multi-platform |

### Edge Cases

1. **No platform match**: If `platforms` is specified but no entry matches a node's OS/arch, the controller returns an error for that node. The install Job is not created and the node is not silently skipped.

2. **Both `platforms` and `anonHttp` specified**: `platforms` takes precedence. If a node doesn't match any platform entry, `anonHttp` is **not** used as fallback — this prevents accidentally deploying the wrong architecture binary.

3. **SHA-256 mismatch**: A checksum mismatch causes the downloader init container to exit non-zero, failing the Job. The controller sees the Job failure and can set a status condition.

4. **OS/Arch validation**: The CRD enforces enum constraints — `os` must be `linux` and `arch` must be one of `amd64`, `arm64`, `x86_64`, or `aarch64`. Additional values can be added to the enum as new platforms are supported.

### Security Considerations

- **SHA-256 verification** is recommended for production use to ensure artifact integrity.
- **HTTPS** is recommended for all artifact URLs.
